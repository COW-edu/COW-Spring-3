# [1WEEK] JAVA 기본

## COW SPRING 3기 PRE-ONBOARDING 학습 과제

본격적으로 Spring 학습에 들어가기 전에 여러분은 객체지향 코드에 대해 학습하고 이해하는 시간을 가지실겁니다!

<<<<<<< HEAD
객체지향 코드를 짜기 위해서는 우리가 사용할 언어인 JAVA에 대해 이해하고 있어야합니다. 
=======
객체지향 코드를 짜기 위해서는 우리가 사용할 언어인 JAVA에 대해 이해하고 있어야합니다.
>>>>>>> 7d404092702712c910f654086ae5c989aed08238

이 온보딩 과제는 이번 COW L2 - Spring에 함께 하시는 9분의 개개인의 역량이 다르기 때문에 가장 최소한으로 알고 계셔야 할 내용을 중심으로 선정해봤어요!

많은 양의 정리를 요구하지 않는 과제이니 이해하신 내용을 토대로 간단하게 정리해주시면 됩니다. (1, 2기의 학습자료가 github에 나와있으니 참고하셔도 좋아요☺️)

개인적으로, 분명 학습했던걸 다 기억하실 수 없으실거예요! 저도 마찬가지이고요.. 공부했던 것을 잘 정리해두는 습관을 가지는 것은 분명 큰 도움으로 돌아올 것이라 생각합니다. 그런 의미로 다들 파이팅해봐요!

---
<<<<<<< HEAD
> 아래의 필수 질문은 모든 분들이 정리하고 학습하셔야하는 내용입니다. 선택 질문은 원하시는 분들만 하시면 되지만 분명 학습하시면 큰 도움이 될 것들을 추려봤습니다! 
=======
> 아래의 필수 질문은 모든 분들이 정리하고 학습하셔야하는 내용입니다. 선택 질문은 원하시는 분들만 하시면 되지만 분명 학습하시면 큰 도움이 될 것들을 추려봤습니다!
>>>>>>> 7d404092702712c910f654086ae5c989aed08238

# 필수

## 자바 역사와 버전별 특징
LTS는 Long Term Support로 오랜기간 지원하는 특별한 버전 에디션.
<<<<<<< HEAD
자바에서 많이 쓰는 LTS버전을 주로 정리해보았다. 
=======
자바에서 많이 쓰는 LTS버전을 주로 정리해보았다.
>>>>>>> 7d404092702712c910f654086ae5c989aed08238
java1
1996년 1월에 공개되었으며 발표 이전에 불린 이름은 Oak였다.
안정화 작업을 거친 1.0.2 버전에서 Java로 이름이 바뀌었다.

java8
오라클이 java를 인수한 후 첫번재 LTS출시버전
32비트 지원 공식적인 마지막 버전
유료버전(오라클), 무료버전(오픈)으로 나뉨
Unsigned Integer 계산
람다식 제공
Stream API제공
Primitive Type과 Reference Type의 차이점
Static Link JNI Library 제공
java11
Open JDK와 Oracle JDK 통합
Oracle JDK가 구독형 유료모델로 전환
G1 GC가 기본 GC로 설정 (GC : Garbage Collection)
람다 지역변수 var 키워드 사용 가능
컬렉션, 스트림 등에 메소드 추가

java17
recode class 키워드 사용 가능
애플 M1 및 이후 프로세서 탑재 제품군에 대한 정식 지원
난수 생성 API 추가
봉인 클래스(Sealed Class) 정식 추가
String 여러줄 사용시 텍스트 블록 기능 사용 가능
NumberFormat,DateTimeFormatter 기능 향상
Stream.toList() 사용 가능

자바 버전 사용비율은 8은 원래 많았지만 17채택 비율이 많아지는 중이다
17선택 이유로는 java 서포트 기간이 길다, 신규버전을 위한 대비용, 스프링부트 3.0부터는 자바 17이상을 지원 등이 있다.

현재는 21까지 나왔으며 21도 LTS 지원을 한다고한다.

---

## Primitive Type과 Reference Type의 차이점
Primitive Type
원시형(기본형) 타입은 정수, 실수, 문자, 논리 리터럴 등의 실제 데이터 값을 저장하는 타입.
int, long, double,float,boolean,byte,short,char
기본 타입은 반드시 사용하기 전에 선언 되어야하며, java에서 미리 정의, 제공한다.

Reference Type
참조타입은 객체를 참조(주소를 저장)하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입.
배열, 열거, 클래스, 인터페이스 이렇게 크게 4가지로 나뉨.

참조형 타입은 빈 객체를 의미하는 Null값 존재.
참조형 타입의 변수는 값이 저장되어 있는 변수의 메모리 주소를 저장하는 공간-> 메모리 영역의 힙(Heap)영역에 저장됨.

참조형 타입의 특성 상 배열이나 객체를 Null 값으로 받으면 NullPointException에러가 발생.

---

## JAVA의 접근 제어자
public, protected, default, private 네가지가 있다.
purblic의 적용 대상은 클래스, 필드, 생성자, 메소드 전부 가능하며 접근할 수 없는 클래스는 없다.
protected의 적용대상은 필드, 생성자, 메소드가 가능하며 접근할 수 없는 클래스는 자식클래스 외 다른 패키지에 소속된 클래스다.
default는 클래스, 필드, 생성자, 메소드 에서 적요앧상이며, 같은 패키지에 소속된 클래스에서만 사용이 가능하다.
private는 필드, 생성자, 메소드 에서 적용가능하며 외부 클래스들은 접근 불가능하다.

---


## static 키워드
static은 '고정된' 또는 '공통적인'의 의미를 가지고 있다.
즉 모든 객체가 공유하는 값이다.
static 값은 클래스 이름을 통해서 접근해야 하며, 객체를 생성하지 않고도 사용할 수 있다.
특히 상수에 많이 쓰인다.
static이 붙은 멤버변수는 객체의 개수에 상관 없이 단 하나만 생성되며,
이를 모든 객체가 공유하기 때문에 메모리를 효율적으로 사용할 수 있다.
<static이 붙은 멤버변수를 사용할 땐 대문자로 쓴 클래스 이름을 사용하면 된다.>
멤버변수 중 모든 객체에 공통으로 사용하는 것에 static을 붙인다.
메서드 내에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에
staitc을 붙이는 것을 고려한다.

나온 의미
<<<<<<< HEAD
멤버변수	
=======
멤버변수
>>>>>>> 7d404092702712c910f654086ae5c989aed08238
모든 객체에 공통적으로 사용되는 클래스 변수가 된다.
클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
클래스가 메모리에 로드될 때 생성된다.

<<<<<<< HEAD
메서드	
=======
메서드
>>>>>>> 7d404092702712c910f654086ae5c989aed08238
객체를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.

---


## final 키워드
기본적으로 final이 붙으면 변경할 수 없다고 생각하면 된다.
1. final 변수
<<<<<<< HEAD
변수 선언할 때 클래스 앞 final 키워드가 들어간다. 이 변수는 초기화 후 변경이 불가능 하다.
2. fianl arguments(인자)
final로 선언된 인자는 메소드 내에서 변경이 불가능하다. 따라서 다음과 같이 final int로 선언한 number는 읽을 수 있지만, number = 2처럼 값을 변경하려고 하면 컴파일 에러가 발생한다
3.final 클래스 
클래스에 final을 붙이면 다른 클래스가 상속할 수 없는 클래스가 된다. 다음과 같이 final 클래스를 상속하려고 하면 컴파일 에러 발생.
4.final 메소드 
final 메소드는 Override가 안되도록 한다. 예를 들어 다음과 같이 MJ 클래스를 상속하는 MMJ 클래스에서는 getHello()를 재정의할 수 없다. Override하려고 하면 컴파일 에러가 발생한다.
=======
   변수 선언할 때 클래스 앞 final 키워드가 들어간다. 이 변수는 초기화 후 변경이 불가능 하다.
2. fianl arguments(인자)
   final로 선언된 인자는 메소드 내에서 변경이 불가능하다. 따라서 다음과 같이 final int로 선언한 number는 읽을 수 있지만, number = 2처럼 값을 변경하려고 하면 컴파일 에러가 발생한다
   3.final 클래스
   클래스에 final을 붙이면 다른 클래스가 상속할 수 없는 클래스가 된다. 다음과 같이 final 클래스를 상속하려고 하면 컴파일 에러 발생.
   4.final 메소드
   final 메소드는 Override가 안되도록 한다. 예를 들어 다음과 같이 MJ 클래스를 상속하는 MMJ 클래스에서는 getHello()를 재정의할 수 없다. Override하려고 하면 컴파일 에러가 발생한다.
>>>>>>> 7d404092702712c910f654086ae5c989aed08238

재할당만을 막아줄 뿐, 참조하고 있는 객체 내부의 상태가 변하지 않았음을 보장해주지는 않는다.

---


## 오버로딩(Overloading)과 오버라이딩(Overriding)
오버로딩
메서드의 이름은 같고 매개변수의 유형과 개수가 다르도록 하는 것
- 리턴값만을 다르게 갖는 오버로딩은 작성할 수 없다.

오버라이딩
-상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용하는 것을 의미한다
메서드의 이름은 물론 파라미터의 개수나 타입도 동일해야 하며, 주로 상위 클래스의 동작을 상속받는 하위 클래스에서 변경하기 위해 사용된다

---

## 추상 클래스와 인터페이스
공통점
객체생성: 객체를 생성(인스턴스화)할 수 없다.
추상메서드: 추상 메서드 포함
기능적 목적: 상속받는 클래스에서는 추상 메서드를 반드시 재정의할여 구현해야 한다.

차이점
개념적 목적
상속 받아서 기능을 확장 | 구현 객체의 동일한 실행 기능 보장

클래스
클래스O | 클래스 X

일반 메서드
일반 메서드 정의 가능 | 일반 메서드 정의 불가능(자바 8 이후 static, default 메서드 정의 가능)

멤버 변수
클래스와 동일하게 변수 선언 및 사용 가능 | 상수만 사용 가능

상속 키워드
extends | implements

다중상속
불가능 | 가능

---

## JAVA Enum
열거형으로 서로 관련된 상수들을 정의하여 편리하게 사용하기 위한 자료형
장수들을 사용하면소 발생했던 문제점, 불편했던 점 들을 개선하고자 jdk1.5부터 추가됨


생긴 이유
코드의 가독성 높혀줌
열거형의 값뿐아니라 타입까지 관리해 오류 저하
상수와 리터럴이 논리적 연관이 없다
서로가른 개넘끼리 이름충돌 가능
서로 다른 개념임에도 비교 연산 가능

<<<<<<< HEAD
 개념
=======
개념
>>>>>>> 7d404092702712c910f654086ae5c989aed08238
num에 정의된 상수들은 해당 enum type의 객체이다

enum Fruit {apple, peach, banana}

Enum에 생성자와 메서드를 추가할 수 있다

enum은 위와 같이 생성자를 정의할 수 있는데, 접근제어자는 private이기 때문에 외부에서 접근할 수 없으며 열거형의 멤버 중 하나를 호출하면 열거된 모든 상수의 객체가 생성된다

값을 가진 enum상수는 생성자도 함께 정의해줘야 함

---

## 객체지향
객체 지향 프로그래밍에서는 이와 같은 각각의 객체를 추상화시켜 속성(state)과 기능(behavior)으로 분류한 후에 이것을 다시 각각 변수(variable)와 함수(function)로 정의.

프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
여러 독립적인 부품들의 조합, 
즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임

장점
코드 재사용 용이: 클래스, 상속 이용
유지보수 쉬움: 해당 부분만 수정
대형프로젝트 적합 : 업무분담이 쉬움

처리속도가 절차지향보다 느림
객체많으면 용량 커질 수 있음
설계시 많은 시간과 노력이 듦

---


## 객체지향 4대 특성
1. 추상화
<<<<<<< HEAD
객체의 공통적인 속성과 기능을 추출하여 정의하는것


2. 상속
기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소
 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용
반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근
재사용성 용이

3. 다형성
객체 지향 프로그래밍의 꽃
어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할수 있는 객체 지향의 특성
오버라이딩 오버로딩이 그 예
4. 캡슐화
서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것
이유
• 데이터 보호(data protection) – 외부로부터 클래스에 정의된 속성과 기능들을 보호
=======
   객체의 공통적인 속성과 기능을 추출하여 정의하는것


2. 상속
   기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소
 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용
   반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근
   재사용성 용이

3. 다형성
   객체 지향 프로그래밍의 꽃
   어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
   어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할수 있는 객체 지향의 특성
   오버라이딩 오버로딩이 그 예
4. 캡슐화
   서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것
   이유
   • 데이터 보호(data protection) – 외부로부터 클래스에 정의된 속성과 기능들을 보호
>>>>>>> 7d404092702712c910f654086ae5c989aed08238

• 데이터 은닉(data hiding) – 내부의 동작을 감추고 외부에는 필요한 부분만 노출


각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적

접근제한자 사용해 캡슐화

---


## SOLID 원칙
SPR(Single Responsibility Principle) 단일 책임 원칙
한 클래스는 하나의 원칙만 가지고 있어야 한다.
다른 책임이 있게되면 결합을 불러온다.
SRP원리를 적용하면 무엇보다도 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로워 진다.
따라서 책임이 적절히 분배되어 코드 가독성, 유지보수 용이 등의 장점이 생긴다.
변경이 있을 때 파급효과가 적으면 단일 책임 원칙이 잘 지켜진다는 것!

OCP(Open Closed Principle) 개방 폐쇄 원칙
클래스나 모듈은 확장에는 열려 있으나, 변경에는 닫혀있어야 한다.
면경을 위한 비용 가능한 축소, 확장 위한 비용은 가능한 극대화
구현에 의존하기 보다는 정의한 인터베이스에 의존하도록 코드를 작성해야 한다.
다형성을 잘 활용해 구현 가능하다.

LSP(Liskov Substitution Principle) 리스코프 치환 원칙
서브 타입은 언제나 기반 타입으로 교체할 수 있어야한다.
하위 클래스의 인스턴스는 상휘형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다는 말이다.
상속은 다형성을 통한 확장성 획득을 목표를 하기 때문에 확장에 대한 인터페이스를 준수해야한다.

ISP(Interface Segregation Principle) 인터페이스 분리 원칙
하나의 일반적인 인터페이스 보다는, 여러 개의 구체적인 인터페이스가 낫다.
한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리다.
가능한 최소한의 인터페이스만을 사용해야 한다는 의미!

SRP가 클래스의 단일책임 강조<->ISP는 인터페이스의 단일책임 강조
ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
ex) 사용자 인터페이스 -> 운전자 클라이언트, 정비사 클라이언트로 분리
분리시 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음


DIP(Dependency Inversion Principle) 의존 역전 원칙
추상화에 의존해야하며, 구체화에 의존하면 안된다
상위 모듈은 하위 모듈의 구현에 의존해서는 안 된다.
하위의 모듈이 상위 모듈에 정의한 추상 타입(interface)에 의존 해야한다.
즉, 상위 클래스에 기반을 두고 생각해야 된다는 것이다.

---


# 선택사항 (추가로 공부하면 좋은 것들입니다!)
이번주 내로 추가하도록 하겠습니다!
## Java Annotation

---

## Lambda, Stream

---

## JVM 내부 구조 & 메모리 영역

---
