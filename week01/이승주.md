# [1WEEK] JAVA 기본

## COW SPRING 3기 PRE-ONBOARDING 학습 과제

본격적으로 Spring 학습에 들어가기 전에 여러분은 객체지향 코드에 대해 학습하고 이해하는 시간을 가지실겁니다!

객체지향 코드를 짜기 위해서는 우리가 사용할 언어인 JAVA에 대해 이해하고 있어야합니다. 

이 온보딩 과제는 이번 COW L2 - Spring에 함께 하시는 9분의 개개인의 역량이 다르기 때문에 가장 최소한으로 알고 계셔야 할 내용을 중심으로 선정해봤어요!

많은 양의 정리를 요구하지 않는 과제이니 이해하신 내용을 토대로 간단하게 정리해주시면 됩니다. (1, 2기의 학습자료가 github에 나와있으니 참고하셔도 좋아요☺️)

개인적으로, 분명 학습했던걸 다 기억하실 수 없으실거예요! 저도 마찬가지이고요.. 공부했던 것을 잘 정리해두는 습관을 가지는 것은 분명 큰 도움으로 돌아올 것이라 생각합니다. 그런 의미로 다들 파이팅해봐요!

---
> 아래의 필수 질문은 모든 분들이 정리하고 학습하셔야하는 내용입니다. 선택 질문은 원하시는 분들만 하시면 되지만 분명 학습하시면 큰 도움이 될 것들을 추려봤습니다! 

# 필수

## 자바 역사와 버전별 특징

---

### 자바의 개발배경과 특징

자바는 다양한 하드웨어와 운영체제에서도 동일한 코드로 동작하는 것 목표로 만들어진 언어로 
'Write Once, Run Anywhere'의 철학을 가지고 만들어졌다.
그러한 특징을 구현하기 위해 JVM상에서 구동되는 특성을 지니고 따라서 환경마다 다른 컴파일러를 요구하지 않는다.
자바는 1991년 6월에 James Gosling에 의해서 만들어졌고, 초기 명칭은 Oak였지만 1996년에 발표된 1.0.2 버전부터 자바(Java)라는 이름을 사용하였다.
자바는 임베디드시스템에 사용하기 위하여 개발되었지만, 그 확장성으로 인하여 웹의 발전과 함께 더욱 각광받는 언어가 되었다.


### 버전별 특징

자바 1.0 ~ 1.02 : 기본적인 객체지향 언어로써의 구조와 규약을 정립

자바 1.1  : 이너클래스, 리플렉션, RMI 등의 기능 추가

자바 1.2  : Swing GUI와 JIT 등의 기능 추가

자바 1.4  : 정규표현식과 XML API의 지원

자바 5   : ClassCastException을 컴파일 과정에서 검증하는 Generics 기능의 추가. Annotation과 Enum의 추가. 기본형데이터를 래퍼클래스로 자동으로 변환해주는 Auto Boxing/Unboxing 추가.

자바 7   : 타입 인터페이스 <T> 를 지원.  

자바 8   : 익명메소드를 생성하는 람다표현식 추가.  람다의 축약형인 Method Reference를 지원.    JVM 메모리 할당 방식의 변경

자바 10  : 변수타입을 자동으로 추론해서 할당하는 'var' 로컬변수타입 추가

자바 11  : 신규 String 메서드 추가

자바 12  : 람다를 통한 Switch문의 확장

자바 13  : Switch문에  yield 예약어 추가




## Primitive Type과 Reference Type의 차이점

---

Primitive Type은 고정된 크기를 가지는 데이터 타입으로 스택 메모리에 저장된다. 해당 타입의 변수를 저장하거나 계산할 때 값을 복사하여 사용하게 된다. Static Final로 선언하면 컴파일 과정에서 코드상의 해당변수 전부가 해당 값으로 변환된다. 
반면 Reference Type은 힙메모리에 동적으로 할당되는 데이터 타입으로, 실행될 때 변수는 해당 객체의 주소로 변환되며 전달또한 레퍼런스를 복사하여 이루어진다. 더이상 해당 객체를 참조하는 변수가 존제하지 않게 되면 가비지 컬렉터에 의해 정리된다.




## JAVA의 접근 제어자

---

객체지향의 특징중 하나인 캡슐화를 구현하기 위해 자바에는 4가지 접근제어자를 사용하여 외부의 접근을 조절한다. 클래스의 멤버와 클래스 자체를 선언할 때 사용한다.


####1. private
private으로 선언된 멤버는 클래스의 외부에서는 접근할 수 없고, public 메서드를 통해서만 접근이 가능하다. 
일반적인 필드와 메서드들을 생성할 때 private으로 설정하고 get, set등의 public 메서드를 통해 접근한다.

####2. default
접근제어자를 지정하지 않고 선언하면 가지는 제어자로, 같은 클래스나 패키지의 멤버만 접근이 가능하다.

####3. protected
같은 패키지내의 멤버들은 모두 접근 가능하고, 다른 클래스에 있더라도 자식클래스의 멤버라면 접근이 가능한 제어자이다. 

####4. public
프로그램의 모든 멤버가 접근 가능하도록 선언하는 제어자로, public메서드를 사용해서 제한된 멤버에 접근이 가능하다. 프로그램의 시작점인 main 메서드에 접근해야만 실행 가능하므로 반드시 public이어야 한다.


## static 키워드

---

static 키워드를 사용하면 해당 멤버를 static영역에 생성되는 정적멤버로 생성할 수 있다. 메서드가 종료되거나 변수가 재대입되면 메모리를 반환하는 stack영역과 달리 static 영역에 할당된 멤버는 프로그램 종료시까지 고정되어 남아있게 된다.
main함수는 종료시까지 고정되어 있어야하고, 시작위치를 알아야하므로 static키워드가 사용된다.


## final 키워드

---

final 키워드는 변수, 메서드, 클래스에 사용될 수 있는 키워드로 
변수에서 사용할 경우 해당 변수는 변경할 수 없게 제한된다. 원시타입 변수의 경우 컴파일 과정에서 그 값으로 변환되고 레퍼런스 변수의 경우 해당 객체의 주소를 다른것으로 변경 할 수 없도록 한다. 
메서드에 사용하면 오버라이딩을 제한하게 된다. 따라서 상속받은 클래스에서 해당 메서드를 변경하기를 원치 않을 때 final 메서드로 선언하게 된다.
클래스에 사용하면 해당클래스를 상속받지 못하게 한다.


## 오버로딩(Overloading)과 오버라이딩(Overriding)

---

오버로딩은 다른 파라메터를 가진 동일한 이름의 메서드를 중복해서 정의할 수 있는 기능을 의미한다. 
파라메터의 개수가 다르거나, 타입이 다르도록 설정하면 같은 이름의 메서드를 정의할 수 있고, 컴파일러가 파라메터를 통해 메서드를 추론하여 컴파일을 진행한다.
오버로딩을 통해 코드의 가독성을 증가시킬 수 있다. 

오버라이딩은 자식클래스 내에서 부모클래스의 메서드를 재정의해서 사용할 수 있는 기능이다.
메서드의 선언부분(메서드 이름, 파라메터, 리턴 타입)이 모두 일치하는 메서드를 자식클래스 내에서 정의하여 사용할 수 있고, 이를 통해서 다형성을 구현 할 수 있다.


## 추상 클래스와 인터페이스

---

추상클래스와 인터페이스는 모두 다형성과 추상화를 위해 상속이나 구현받은 클래스의 메서드나 필드를 강제하는 역할을 한다. 영향을 받는 여러 클래스에게 공통적인 기능 또는 속성을 가지게 한다는 특징은 같지만 목적과 기능에 다소 차이가 있다.

인터페이스는 서로 다른 애플리케이션의 클래스끼리 통신하거나, 상속관계가 아니지만 기능적으로 유사한 클래스들을 묶어 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다. 
public으로만 선언가능하고, 추상메서드나 static, default, pivate 메서드만 사용가능하다. 하나의 클래스가 여러개의 인터페이스를 구현하는 것이 가능하고, 인터페이스를 구현하면 반드시 모든 추상 메서드를 구현해야한다. 
예를 들어 MouseListner 인터페이스를 구현하면 사용하지 않더라도 모든 추상클래스를 구현해야하고, 마우스가 동작할 때 OS가 해당 메서드를 호출하는 방식으로 통신하게 된다.

추상클래스는 어떤 클래스를 상속받을 자식클래스들을 추상화하여 공통적인 기능과 속성(메서드와 필드)을 나타낸 클래스로, 논리적인 계층구조를 명확히하기 위해 사용한다. 
abstract 키워드로 선언하고 다중상속이 불가능하다. new로 직접 인스턴스화 할수 없고 공통적으로 구현해야 하는 기능을 미리 메서드로 정의하고 필요시 오버라이딩하여 사용한다. 

## JAVA Enum

---

Enum은 상수를 보다 가독성있고 유지보수가 용이하도록 관리하면서, 기능적으로도 부족하지 않도록 활용하기 위한 데이터 타입이다. 
Enum은 하나의 클래스 처럼 사용하여 상수들을 객체로 취급할 수 있도록 한다. 따라서 Enum은 자체적으로 여러 내장메서드를 가지고 있고, 직접 생성자를 비롯한 여러메서드와 필드를 작성하여 각 상수마다 필드를 맵핑할 수 있다. 

## 객체지향

---

객체지향은 절차지향과 반대로 객체, 즉 명사에 중심을 두고 설계하는 프로그래밍 방식이다. 
한국인은 먹고, 달리고, 한국어를 구사할 수 있지만, 강아지는 먹고 달리는 것이 가능하지만 다른 방식으로 작동하고 한국어를 구사할 수는 없다. 이처럼 동사(함수/메서드)는 명사(객체)에 종속되므로 객체를 기준으로 소프트웨어를 설계하는 방식이 객체지향 프로그래밍이다.
객체를 중심으로 프로그래밍 하게되면 해당 객체에 필요한 요소들이 전부 그 안에 포함되게 되므로(캡슐화), 그 객체를 다른곳에 사용하거나 유사한 다른 객체를 구현(상속)하기 쉬워지고, 유사한 객체들을 하나의 묶음으로 만들어 논리적인 구조를 명확히 할 수 있다. 


## 객체지향 4대 특성

---

캡슐화 : 코드와 데이터를 하나로 묶어 외부에서의 접근을 제어하고 데이터의 무결성을 보호한다. 따라서 클래스(객체)가 독립적으로 사용될 수 있다.

상속 : 클래스가 다른 클래스로부터 필드와 메서드를 이어받아 재사용할 수 있도록 하는것으로, 이를 통해 코드의 재사용성과 유지보수성을 증가시키고, 상속을 통해 다형성을 구현할 수 있게 한다.

다형성 : 논리적으로 유사한 객체가 동일한 인터페이스(클래스)를 통해 같은 메서드를 통해 동작하는 것으로, 절차지향과 다르게 코드구현을 유연하게 만들어주는 특성이다.

추상화 : 객체에서 공통적인 특성을 추출해서 하나의 인터페이스(클래스)로 만들어 내는 것을 말한다. 추상화를 통해 코드는 확장성을 가지게 된다. 




## SOLID 원칙

---

Single Responsibility Principle - SRP : 하나의 클래스는 하나의 책임(기능)만을 담당해야한다. 하나의 클래스가 여러(다른 목적의) 기능을 가지게 되면 수정사항이 일어났을 때 여러 클래스의 수정이 필요해 질 수 있으므로 유지보수성을 위해서는 하나의 기능만을 담당해야 한다.

Open-Closed Principle - OCP : 확장에는 열려있어야 하며, 수정에는 닫혀있어야 한다. 새로운 기능이 추가될 때 기존의 코드는 변경하지 않으면서 쉽게 추가 할 수 있어야 한다. 

Liskov Substitution Principle - LSP : 다형성을 구현하기 위한 원칙으로 업캐스팅된 자식클래스는 언제나 부모클래스를 대체 할 수 있어야 한다. 

Interface Segregation Principle - ISP : 자신이 사용하지 않는 메서드에 의존하지 않도록 인터페이스는 최소한의 동작만을 제공하도록 해야한다.

Dependency Inversion Principle - DIP : 낮은계층의 클래스에 의존하지 않고 상위 요소에 의존해야한다.




# 선택사항 (추가로 공부하면 좋은 것들입니다!)

## Java Annotation

---

## Lambda, Stream

---

## JVM 내부 구조 & 메모리 영역

---
