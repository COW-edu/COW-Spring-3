# ７주차 과제－Spirng 사전 조사

## 스프링의 장점／사용 이유

### 스프링

- JAVA의 웹 프레임워크로 JAVA 언어를 기반으로 사용한다. JAVA로 다양한 어플리케이션을 만들기 위한 프로그래밍 틀이며, JAVA 기술들을 더 쉽게 사용할 수 있게 해주는 오픈소스 프레임워크이다.
- 엔터프라이즈용 JAVA 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 경량급 애플리케이션 프레임워크이다.

### 사용 이유

- POJO기반의 구성
    - 코드를 개발할 때, 개발자가 특정한 라이브러리나 컨테이너의 기술에 종속적이지 않음을 의미한다. JAVA 코드를 이용해서 객체를 구성하는 방식 그대로 스프링에서 사용할 수 있다.
    - 개발자는 가장 일반적인 형태로 코드를 작성하고 실행할 수 있다. 때문에 높은 생산성과 유연한 테스트를 할 수 있다는 장점을 가지고 있다.
- DI를 통한 객체 관계 구성
    - 메소드나 객체의 호출 작업은 제어의 역전을 통해 외부에서 이루어진다.
    - 제어의 역행을 전제 조건으로 의존성 주입이 일어난다.
    - 의존성을 가진 객체에 대해 스프링에서 의존성 주입이 발생하도록 한다.
    - 의존성 주입 특징으로 인해 개발자가 POJO 개발이 가능하게 된다.
    - 의존성 주입 방법
        - 필드 주입
        - setter 주입
        - 생성자 주입(권장)
        - 생성자 주입을 권장하는 이유
            - 순환 의존성 확인: 필드 주입으로는 순환 의존성을 파악하기 어렵다. 생성자 주입을 하게 되면 서버 기동 시 순환 의존성을 가지는 요소들을 파악하게 할 수 있게 에러메시지를 표시하면서 서버 기동이 되지 않는다.
            - 불변성: 필드 주입은 final을 선언할 수 없지만 생성자 주입은 final을 선언함으로써 객체가 변하지 않도록 방지해준다.
            - 단일 책임 원칙 위반 확인
- AOP 지원
    - 코드의 관심사를 분리하고 모듈화하는 프로그래밍 기법이다.
    - 로깅, 보안, 트랜잭션과 같은 코드의 횡단 관심사를 따로 분리하여 관리한다.
    - 각 관심사를 독립적으로 개발하고 유지보수할 수 있어 코드의 가독성과 유지 보수성을 향상시킨다.

### 장점

- 웹 시스템, 웹 서비스를 비롯해 클라우드 애플리케이션, 모바일 시스템 등 다양한 개발에 적합하다. 기능 확장성이 뛰어난 SPRING은 대규모 개발이나 세부 사양 변경에도 유연하게 대응이 가능하다.
- 프레임워크이기 때문에, 개발자의 수준과 실력에 상관없이 일정 수준의 품질을 기대할 수 있다. 담당자 혹은 개발자가 도중에 바뀌더라도, 유지보수에 관한 리스크를 줄일 수 있다.

## **싱글톤, 싱글톤 컨테이너**

### 싱글톤

- 싱글톤 패턴은 특정 클래스의 인스턴스를 1개만 생성되는 것을 보장하는 디자인 패턴이다. 즉, 생성자를 통해서 여러 번 호출이 되더라도 인스턴스를 새로 생성하지 않고 최초 호출 시에 만들어두었던 인스턴스를 재활용하는 패턴이다.
- 싱글톤 패턴을 사용함으로써 얻을 수 있는 이점 중 하나는 메모리 낭비를 방지할 수 있다.
- 사용자가 1초에 10번 똑같은 요청을 보내면 요청을 처리하기 위한 똑같은 객체를 1초에 10번 생성하고 소멸되는 메모리 낭비 문제가 발생하게 된다. 하지만 싱글톤 패턴을 사용하면 최초 한 번 `new`로 객체를 생성하고 해당 객체를 이후에도 사용하도록 공유하면 메모리 낭비를 방지할 수 있다.

### 싱글톤 컨테이너

- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 **싱글톤 레지스트리**라고 한다.
- 스프링 컨테이너의 이러한 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
    - 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도된다.
    - DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다.
- 스프링 컨테이너 덕분에 고객의 요청이 올 때마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있다.

## **레이어드 아키텍쳐 패턴**

- 레이어드 아키텍처는 많은 분야에서 사용되는 아키텍처이다.
- 이름 그대로 여러 레이어를 분리하여 레이어마다 해야 할 역할을 정의해놓은 구조이다.

![https://user-images.githubusercontent.com/79494088/175446442-f3998d69-2e77-4b08-a9b7-8deacb6bd2ff.png](https://user-images.githubusercontent.com/79494088/175446442-f3998d69-2e77-4b08-a9b7-8deacb6bd2ff.png)

- 대표적인 레이어드 아키텍처인 4 계층(4 Layered) 아키텍처의 각 레이어를 정리하면 아래와 같다.
- 프레젠테이션 레이어
    - 인터페이스와 애플리케이션이 연결되는 곳이다.
    - 웹 통신 프레임워크, CLI 등 인터페이스, 입출력의 변환 등 외부와의 통신을 담당한다.
- 애플리케이션 레이어
    - 소프트웨어가 제공하는 주요 기능(비즈니스 로직)을 구현하는 코드가 모이는 곳이다.
    - 로직을 오케스트레이션하고, 트랜잭션의 시작과 끝을 담당한다.
- 도메인 레이어
    - 도메인과 관련된 객체들이 모이는 곳이다.
    - 도메인 모델(엔티티, 값 객체), 도메인 서비스 등 도메인 문제를 코드로 풀어내는 일을 담당한다.
- 인프라스트럭처 레이어
    - 다른 레이어을 지탱하는 기술적 기반을 담은 객체들이 모이는 곳이다.
    - DB와의 연결, ORM 객체, 메시지 큐 등 애플리케이션 외적인 인프라들과의 어댑터 역할을 담당한다.
- 레이어드 아키텍처는 의존성의 방향이 다음처럼 흐른다.
    - 프레젠테이션 레이어 -> 애플리케이션 레이어 -> 도메인 레이어 -> 인프라스트럭처 레이어
- 즉 프레젠테이션 레이어에 있는 코드는 애플리케이션 레이어에 있는 코드에 의존해야 한다.
- 그 반대인 애플리케이션 레이어 코드가 프레젠테이션 레이어에 있는 코드에 의존하면 안된다.
- 이처럼 의존성의 흐름은 항상 프레젠테이션 레이어에서 인프라스트럭쳐 레이어로 흘러야한다.
- 위는 4개의 레이어로 구성한 예이고, 3개의 레이어로 구성할 수도 있다.
- 3 레이어의 경우 보통 다음처럼 구성한다.
    - 프레젠테이션 레이어 -> 애플리케이션 레이어 -> 데이터 접근 레이어

## **스프링 어노테이션 10개 이상 정리**

### @SpringBootApplication

- Srping Boot를 자동으로 실행시켜주는 어노테이션으로 Bean 등록은 두 단계로 진행된다.
    - `@ComponentScan`을 통해 Component들을 Bean으로 등록한다.
    - `@EnableAutoConfiguration`을 통해 미리 정의해둔 자바 설정 파일들을 Bean으로 등록한다.(Bean은 스프링 IoC 컨테이너에 의해 인스턴스화되어 조립되거나 관리되는 객체)

### @Configuration

- 스프링 IoC Container에게 해당 클래스가 Bean 구성 Class임을 알려주는 어노테이션이다.
- `@Bean`을 해당 클래스의 메소드에 적용하면 `@Autowired`로 빈을 부를 수 있다.

### @EnableAutoConfiguration

- Spring Application Context를 만들 때 자동으로 설정하는 기능을 켠다.
- classpath의 내용에 기반해서 자동 생성해 준다.
- 만약 tomcat-embed-core.jar가 존재하면 톰캣 서버가 setting된다.

### @ComponentScan

- `@Component`, `@Service`, `@Repository`, `@Controller`, `@Configuration`이 붙은 빈들을 찾아서
- Context에 빈을 등록해 주는 어노테이션이다.
- `@Component` 어노테이션이 있는 클래스에 대하여 bean 인스턴스를 생성한다.
- Spring에서 `@Component`로 다 쓰지 않고 `@Repository`, `@Service`, `@Controller`등을 사용하는 이유는, 예를들어 `@Repository`는 DAO의 메소드에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.
- 또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.

### @Component

- 개발자가 직접 작성한 Class를 Bean으로 등록하기 위한 어노테이션이다.
- `@ComponentScan`선언에 의해 특정 패키지 안의 클래스들을 자동 스캔하여 `@Component` 어노테이션이 있는 클래스들에 대하여 Bean 인스턴스를 생성한다.

```java
@Component
public class Student {
	public Stdudent() {
    	System.out.println("hello");
    }
}

@Component(value="mystudent")
public class Student {
	public Stdudent() {
    	System.out.println("hello");
    }
}
```

- Component에 대한 추가 정보가 없다면 Class의 이름을 camelCase로 변경한 것이 Bean id로 사용된다. 하지만 `@Bean`과 다르게 `@Component`는 name이 아닌 value를 이용해 Bean의 이름을 지정한다.

### @Bean

- `@Bean`은 개발자가 직접 제어가 불가능한 외부 라이브러리 등을 Bean으로 만들 때 사용되는 어노테이션이다.

```java
@Configuration
public class ApplicationConfig {
	@Bean
    public ArrayList<String> array() {
    	return new ArrayList<String>();
    }
}
```

- ArrayList같은 라이브러리등을 Bean으로 등록하기 위해서는 별도로 해당 라이브러리 객체를 반환하는 Method를 만들고 `@Bean`을 사용하면 된다. 위의 경우 `@Bean`에 아무런 값을 지정하지 않았으므로 Method 이름을 camelCase로 변경한 것이 Bean id로 등록된다.
- 메소드가 `arrayList()`인 경우 arrayList가 Bean id가 된다.
- `@Bean`에 name이라는 값을 이용하면 원하는 id로 Bean을 등록할 수 있다.

### @Autowired

- 필드, setter 메소드, 생성자에 사용하며 Type에 따라 알아서 Bean을 주입해주는 역할을 한다.
- 객체에 대한 의존성을 주입시킨다.
- `@Autowired`을 사용하면 스프링이 자동적으로 값을 할당한다.
- Controller 클래스에서 DAO나 Service에 관한 객체들을 주입 시킬 때 많이 사용한다.
- Bean을 주입받는 방식(3가지)
    1. `@Autowired`
    2. setter
    3. 생성자: `@AllArgsConstructor` 사용, 스프링에서는 생성자를 통한 방식을 권장한다.

### @Controller

- Spring MVC의 Controller로 사용되는, 클래스 선언을 단순화 시켜주는 어노테이션이다.

### @RestController

- Spring에서 Controller 중 View로 응답하지 않는 Controller를 의미한다.
- method의 반환 결과를 JSON 형태로 반환한다.
- `@RestController`가 적혀있는 Controller의 method는 HttpResponse로 바로 응답이 가능하다.
- `@ResponseBody` 역할을 자동적으로 해주는 어노테이션이다.
- @Controller와 @RestController의 차이점
    - @Controller
        - API와 view를 동시에 사용하는 경우에 사용한다.
        - 대신 API 서비스로 사용하는 경우는 `@ResponseBody`를 사용하여 객체를 반환한다.
        - `view` return이 주목적이다.
    - @RestController
        - view가 필요없는 API만 지원하는 서비스에서 사용한다.
        - `@RequestMapping` 메서드가 기본적으로 `@ResponseBody` 의미를 가정한다.
    - @RestController  =  @Controller  +  @ResponseBody

### @Service

- Service class에서 쓰이는 어노테이션으로, 비즈니스 로직을 수행하는 Class라는 것을 나타내는 용도이다.

### @Repository

- DAO class에서 쓰이는 어노테이션이다.
- DB에 접근하는 method를 가지고 있는 Class에서 쓰인다.

### @Resource

- `@Autowired`와 마찬가지로 Bean 객체를 주입해주는데 차이점은 Autowired는 타입으로, Resource는 이름으로 연결해준다.
- 어노테이션 사용으로 인해 특정 Framework에 종속적인 어플리케이션을 구성하지 않기 위해서는 `@Resource`를 사용할 것을 권장한다.
- `@Resource`를 사용하기 위해서는 class path 내에 jsr250-api.jar 파일을 추가해야 한다.
- 필드, 입력 파라미터가 1개인 bean property setter method에 적용 가능하다.

### @Getter

- 자동으로 생성된 접근자와 설정자 메소드를 사용할 수 있어 매우 편리하다.
- 필드 레벨이 아닌 클래스 레벨에 @Getter 또는 @Setter를 선언해줄 경우, 모든 필드에 접근자와 설정자가 자동으로 생성된다.
- 자바 언어에서 속성의 값을 가져오는 메서드를 자동으로 생성하는 어노테이션이다.
- 클래스의 필드에 대한 getter 메서드를 명시적으로 작성하지 않고도 해당 필드의 값을 가져올 수 있다.

### @AllArgsConstructor

- 클래스의 모든 필드에 대한 생성자를 자동으로 생성한다.
- 클래스의 모든 멤버 변수를 매개변수로 받는 생성자를 자동으로 만들어 준다.
- 생성된 생성자를 통해 객체를 생성할 때, 각 필드에 대한 값을 인자로 전달할 수 있다.

### @RequiredArgsConstructor

- 클래스의 final 필드에 대한 생성자를 자동으로 생성한다.
- final 필드는 클래스에서 초기화를 하던지 객체 생성 시 생성자를 이용해 꼭 초기화해줘야한다.