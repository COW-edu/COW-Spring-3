# 7주차 과제 - Spring 사전 조사

5/7 화요일 23:59 까지 제출해주시면 되겠습니다.

## 스프링의 장점 / 사용 이유

Spring은 자바 플랫폼을 위한 오픈 소스 애플리케이션이다. 이를 사용함으로 얻을 수 있는 장점은 다음과 같이 알아볼 수 있었다. 
Java 엔터프라이즈 개발을 보다 편리하게 가능하게 하는데 이는 결국 기술적은 문제보다 애플리케이션의 비즈니스 로직 자체에 집중할 수 있다는 것과 같다.
또한, Spring은 POJO 프로그래밍을 지향하는데 이는 저번 세션에서도 언급되었던 내용 중 하나이다. 스프링의 기본 구조는 `IoC`, `DI`, `AOP`, `PSA`라는 주요 기술
을 통해 애플리케이션을 POJO로 개발할 수 있게 해준다. (여기서 POJO는 오래된 방식의 간단한 자바 오브젝트로, 무거운 객체를 만들게 된 것에 반발해서 사용하게 된
용어이다.)

* `DI(Dependency Injection)`
: 객체 간의 의존관계를 직접 설정하는 것이 아닌 외부에서 생성하여 주입시키는 개념의 디자인 패턴

* `Ioc(Inversion of Control)`
:  이는 원칙의 개념으로, DI는 IoC라는 원칙을 지키기 위한 다양한 디자인 패턴 중 하나이다. 이는 유연하고 확정성이 뛰어난 코드를 작성하기 위한
목표를 가지기 위함이다.


## 싱글톤, 싱글톤 컨테이너

싱글톤 패턴은 클래스의 인스턴스가 딱 1개만 생성된느 것을 보장하는 디자인 패턴으로 객체 인스턴스 2개 이상을 생성하지 못하도록 한다.
이는 private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다. 해당 싱글톤 패턴을 구현하는 코드를 구현하면서 지켜야할 것은 `static` 필드로 인스턴스를 미리 생성해두고,
만들어둔 인스턴스의 참조를 반환하는 메서드를 정의하며 private 생성자를 만들게 된다. 이러한 싱글톤 패턴의 문제는 테스트하기가 어려운 점이 있고, 내부 속성을 변경하거나 초기화하기 어렵다는 점이 존재한다,
또한, private 생성자로 자식 클래스를 만들기 어렵다는 단점 역시 가진다.

이러한 단점을 해결해 줄 수 있는 것이 싱글톤 컨테이너이다.
스프링 컨테이너는 싱글턴 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다. 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.
스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리하며, 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
스프링 컨테이너의 이러한 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도된다.
DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다.

## 레이어드 아키텍쳐 패턴
코드 아키텍처를 구상할 때는 확장성(extensibility), 재사용성(reusability), 유지 보수 가능성(maintainabiliy), 가독성(readability)를 염두해야 한다. 이러한 염두를 둔 백엔드 API 패턴인 `레이어드 아키텍쳐 패턴`이 존재한다. 
`Multi-tier 아키텍처 패턴`이라고도 하는 레이어드 아키텍처는 코드를 논리적인 부분 혹은 역할에 따라 독립된 모듈로 나누어서 구성하는 패턴이다. 그리고 각 모듈이 서로의 의존도에 따라 층층히 쌓듯이 연결되어서 전체의 시스템을 구현하는 구조이며,
마치 레이어(layer)를 쌓아 놓은 것 같은 형태의 구조가 된다. 
보통 다음과 같은 레이어가 존재한다.

1. Presentation Layer
: Presentation layer는 해당 시스템을 사용하는 사용자 혹은 클라이언트 시스템과 직접적으로 연결되는 부분이다.. 웹사이트에서는 UI 부분에 해당하고 백엔드 API에서는 엔드포인트 부분에 해당하며, 
presentation layer에서 API의 엔드포인트들을 정의하고 전송된 HTTP 요청(request)를 읽어 들이는 로직을 구현한다. 
하지만 그 이상의 역할은 담당하지 않습니다. 실제 시스템이 구현하는 비즈니스 로직은 다음 레이어로 넘기게 됩니다.
   다음과 같은 역할을 담당합니다.

   - EndPoint
   - Authentication
   - JSON Translation

2. Business Layer
: Business layer라는 이름 그대로 비즈니스 로직을 구현하는 부분이다. 실제 시스템이 구현해야하는 로직을 이 레이어에서 구현하게 됩니다. 백엔드 API에서는  Presentation layer에서 전송된 요청을 읽어들여 요청에 맞게 동작하는 로직을 구현하면 됩니다. 예를 들어 회원가입 요청 시 필수적인 요소들이 다 포함되어 있지 않으면 거부한다던가 하는 로직 등이 비즈니스 로직이며, buisiness layer에서 구현하게 됩니다.
   다음과 같은 역할을 담당합니다.

   - Business Logic
   - Validation
   - Authorisation


3. Persistence Layer
: Persistence layer는 데이터베이스와 관련된 로직을 구현하는 부분입니다. Business layer에서 필요한 데이터를 생성, 수정, 읽기 등을 처리하여 실제로 데이터베이스에서 데이터를 저장, 수정, 읽어 들이기를 하는 역할을 합니다.
   다음과 같은 역할을 담당합니다.

   -  Storage Logic




## 스프링 어노테이션 10개 이상 정리

1. `@SpringBootApplication` 
: 스프링 부트 애플리케이션의 메인 클래스에 사용되며, 스프링의 가장 기본적인 설정을 자동으로 구성해주는 어노테이션으로, 
`@Configuration`, `@EnableAutoConfiguration`, `@ComponentScan`을 포함한다.

2. `@RestController`
: 트롤러 클래스를 RESTful 웹 서비스 컨트롤러로 지정합니다. `@Controller`와 `@ResponseBody`를 합친 어노테이션으로, JSON이나 XML 형태로 객체 데이터를 HTTP 응답 본문에 바로 매핑할 수 있게 해준다.

3. `@RequestMapping`
: 요청 URL을 컨트롤러의 메서드와 매핑할 때 사용합니다. `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` 등의 구체적인 HTTP 메서드를 위한 어노테이션도 존재한다.

4. `@Autowired`
: 스프링의 의존성 주입(Dependency Injection) 기능을 구현할 때 사용합니다. 스프링 컨테이너가 자동으로 선언된 빈(Bean)을 찾아서 주입해준다.

5. `@Service`
: 서비스 클래스를 나타내며, 비즈니스 로직을 처리하는 클래스에 붙여 사용하고, 이 어노테이션은 주로 비즈니스 로직을 처리하는 서비스 클래스를 스프링 컨테이너에 빈으로 등록하는 데 사용한다.

6. `@Repository`
: 데이터 접근 계층(DAO)의 클래스에 사용되며, 이 어노테이션을 사용함으로써 클래스가 데이터 접근 계층의 역할을 한다는 것을 스프링에게 알린다. 또한 데이터베이스 예외를 스프링의 데이터 접근 예외로 변환해준다.

7. `@Entity`
: JPA(Java Persistence API)에서 엔티티 클래스를 나타내기 위해 사용되며, 데이터베이스 테이블과 매핑됩니다.

8. `@Transactional`
: 메서드 또는 클래스에 트랜잭션 관리를 적용할 때 사용합니다. 선언적 트랜잭션 관리에 사용되며, 해당 어노테이션이 붙은 메서드나 클래스에서 데이터베이스 트랜잭션이 자동으로 관리한다.

9. `@NoArgsConstructor`
: 파라미터가 없는 디폴트 생성자를 자동으로 생성하고, 이 어노테이션을 사용하면, 클래스에 명시적으로 선언된 생성자가 없더라도 인스턴스를 생성할 수 있다.

10. `@AllArgsConstructor`
: 클래스의 모든 필드 값을 파라미터로 받는 생성자를 자동으로 생성한다. 이 어노테이션을 사용하면, 클래스의 모든 필드를 한 번에 초기화할 수 있다.


## Postman 설치해오기

네. 확인했습니다.
