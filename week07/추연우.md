# 7주차 과제 - Spring 사전 조사

---

## 스프링의 장점 / 사용 이유

- POJO(Plain Old Java Object) 기반의 구성
    - 개발을 할 때에 개발자가 특정한 라이브러리나 컨테이너의 기술에 종속적이지 않고 개발이 가능하다.
    - Java 코드를 이용해서 객체를 구성하는 방식 그대로 스프링에서 이용 가능
- DI(Dependency Indection, 의존성 주입)를 통한 객체 관계 구성
    - 의존성 주입은 필요한 객체를 외부에서 결정하여 연결시키는 것을 말함
    - Java에서는 인터페이스를 사용하여 이를 처리
    - 의존성 주입의 특징으로 인해 개발자가 POJO 개발이 가능해짐
    - 의존성 주입 방식
        - 필드 주입
        - setter 주입
        - 생성자 주입 (권장)
            - 권장 이유
                - 순환 의존성 확인 : 필드 주입으로는 순환 의존성 파악 어려움
                - 불변성 : 필드 주입은 Final 선언이 불가하지만, 생성자 주입은 Final 선언이 가능하여 불변성을 보장할 수 있다.
                - 단일 책임 원칙 확인
- AOP(Aspect Oriented Programming, 관점 지향 프로그래밍) 지원
    - AOP를 통해 반복적인 코드를 줄이고 개발자가 핵심 기능 구현에만 집중할 수 있도록 지원
    ![스크린샷 2024-05-07 145836](https://github.com/COW-edu/COW-Spring-3/assets/111961655/566c411f-0b62-4b98-8260-146802492c08)
  - 위처럼 프로그래밍하면 시간 측정 로직을 수정해야하면 모든 로직을 찾아가서 일일이 수정해야하는 번거로움이 생긴다.
    ![스크린샷 2024-05-07 145946](https://github.com/COW-edu/COW-Spring-3/assets/111961655/23ab95ff-986e-4d3c-b16d-92ce303ccf7f)
  - 이렇게 AOP를 사용하여 공통으로 들어가는 로직을 분리하면 해당 로직만 수정하면 됨

- IoC(Inversion of Control) 지원
    - IoC는 객체의 생성과 생명 주기를 관리해주기 때문에 개발자는 의존성 관리에 신경 쓸 필요 없이 핵심 기능 구현에만 집중 가능
- MVC(Model - View - Controller) 구조
    - Model : 프로그램의 데이터이며 모든 데이터를 가공하여 가지고 있는 컴포넌트
    - View : 시각적인 UI 요소를 지칭하는 용어
    - Controller : Model과 View를 연결하는 역할을 수행
- WAS(Web Application Server)에 독립적인 개발 환경
    - 일반 웹 서버는 정적인 데이터를 처리하는 서버로 단순 이미지 HTML을 처리하는 서버이지만 WAS는 동적인 데이터를 처리하는 서버로, DB연동 데이터 조작 등과 같은 처리가 가능

## 싱글톤, 싱글톤 컨테이너

- 싱글톤 : Class의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 싱글톤 필요 이유
    - 웹 애플리케이션의 이용량이 많아지면 스프링 컨테이너에서는 객체들이 이용량 횟수 만큼 생성되어야함. → 굉장히 비효율적, 메모리낭비
    - 이러한 문제를 해결하기 위해 싱글톤 패턴을 사용하여 하나의 객체를 재사용하여 메모리 낭비를 줄임
- 문제점
    - 구현해야할 코드의 양이 늘어남
    - DIP를 위반하게 됨 → 클라이언트가 구현체에 의존
    - 내부 속성을 변경하거나 초기화하기 어렵다
    - Private 생성자이기 때문에 자식 클래스를 만들기 어렵다
- 싱글톤 컨테이너 : 스프링의 컨테이너는 객체 인스턴스를 싱글톤으로 관리하는 싱글톤 컨테이너의 역할 수행 → 싱글톤의 단점 해결하고 장점만 가져감.
    - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 싱글톤으로 객체들을 관리
    - 스프링 컨테이너는 싱글톤 컨테이너의 역할을 수행 → 싱글톤 레지스트
    - 각각의 Bean들은 싱글톤 패턴 적용을 위한 코드 작성 필요 X
- 주의점
    - 싱글톤 패턴에서는 객체의 인스턴스를 하나만 생성하여 공유하기 때문에 여러 클라이언트에서 해당 인스턴스를 공유
    - 위의 이류로 객체가 상태를 유지하는 stateful 상태이면 문제가 발생 → stateless 상태로 객체 설계 필요
    - 방법
        - 특정 클라이언트에 의존적인 필드가 없어야함
        - 특정 클라이언트가 값을 변경할 수 있는 필드가 존재하면 안됨
        - 가급적 읽기만 가능해야함

## 레이어드 아키텍쳐 패턴

- 정의
    - 소프트웨어 시스템을 관심사 별로 여러 개의 계층으로 분리한 아키택처를 의미
    - 각 계층은 애플리케이션 내에서 특정 역할과 책임 존재 → 각자의 역할에만 집중해야함 && 구성 요소간의 관심사 분리
- 구성 요소들은 추상화된 인터페이스로만 소통함 → 자신보다 하위 계층에만 요청 가능(상위 계층이나 인접하지 않는 계층에는 요청 X) → 단방향 의존성
- 가장 일반적인 레이어드 아키텍쳐
    - 4 - tier 아키텍쳐

![스크린샷 2024-05-07 152753](https://github.com/COW-edu/COW-Spring-3/assets/111961655/44ec3406-adb6-4343-a0cc-662466384f78)
  - Presentation Layer
  → 사용자 혹은 클라이언트 시스템과 직접적으로 연결되는 부분
  - Business Layer
    → 비즈니스 로직을 구현하는 부분. 실제로 시스템이 구현해야하는 핵심 로직 담당
  - Persistence Layer
    →데이터의 영구 저장과 관리를 담당하는 부분
  - Database Layer
    → 실제 DB


- 레이어드 아키텍처 Close
    - 계층간 요청이 이동할 때 인접한 계층을 통과하는 것 → 계층을 뛰어넘어서 접근 불가
    - 관심사의 분리를 위해서 → 한 계층에서 변경이 발생했을 때 다른 계층에 영향 최소화
- 레이어드 아키텍처 Open
    - 특정 요청에만 추가적인 계층이 필요한 경우 이 계층을 Open하여 필요한 경우에 사용하고 아닌 경우에는 우회할 수 있도록 함.
- 레이어드 아키텍처 장단점
    - 장점
        - 계층별로 분리되어 코드의 재사용성과 유지보수성 증가
        - 각 계층이 독립적으로 개발, 확정, 변경 가능
        - 테스트에 용이하다
    - 단점
        - 계층간 통신을 통해 동작하여 데이터의 전달 및 변환 과정에서 일부 오버헤드가 발생
        - 계층 간 통신을 위한 인터페이스와 로직을 추가해야하므로 복잡성이 증가함

## 스프링 어노테이션 10개 이상 정리

- @Component
    - 생성한 class를 Spring의 Bean으로 등록할 때 사용
- @Controller
    - Spring에서 해당 Class가 Controller의 역할을 한다고 명시하기 위해 사용
- @RequestMapping(value = “”)
    - 요청 들어온 URL의 요청과 Annotaion value값이 일치하면 해당 클래스나 메소드를 실행
    - Controller 객체 안의 메소드와 클래스에 적용 가능
- @RequestParam
    - URL에 전달되는 파라미터를 메소드의 인자와 매칭시켜 파라미터를 받아서 처리할 수 있게 만들어줌
    - JSON 형식의 Body를 MessageConverter를 통해 Java 객체로 변환
- @RequestBody
    - 클라이언트가 보내는 HTTP 요청 본문을 Java 오브젝트로 변환
    - 클라이언트가 Body에 JSON이나 XML과 같은 형태로 값을 전송하면 이를 Java Object로 변환
- @Autowired
    - Spring Framework에서 Bean 객체를 주입받기 위해 사용
    - 주입 방식
        - @Autowired
        - 생성자 주입
        - setter 사용
- @GetMapping
    - RequestMapping(Method=RequestMethod.GET)과 똑같은 역할
- @PostMapping
    - RequestMapping(Method=RequestMethod.POST)과 똑같은 역할
- @Setter
    - Class 모든 필드의 Setter Method 생성
- @Getter
    - Class 모든 필드의 Getter Method 생성