
## 인터넷과 네트워크
- 네트워크(좁은 의미로 컴퓨터)와 네트워크를 연결하면 인터넷이라고 합니다. 즉, 서로 다른 컴퓨터 두 대가 연결되기만 해도 이를 인터넷이라고 부를 수 있는 것
- 컴퓨터와 컴퓨터를 연결한 범위가 전 세계적으로 크다면, 인터넷, 컴퓨터와 컴퓨터가 한 대만 연결되어 있어도 되는 작은 범위는 네트워크

### 인터넷
- 전 세계에 퍼져 있는 상호 연결된 장치의 모음
- 목적은 인터넷을 통해 지식을 얻고 소통하는 것
- 전 세계의 다양한 유형의 전기 장치를 연결하는 글로벌 시스템
- 인터넷은 네트워크의 한 종류

### 네트워크
- 네프린터, 인터넷 연결, 애플리케이션 등과 같은 리소스를 공유할 수 있는 두 대 이상의 연결된 컴퓨터 그룹으로 정의 
- 목적은 동료들과 데이터를 교환하고 협력하는 것
- LAN, WAN, CAN 또는 HAN을 사용하여 서로 연결되는 컴퓨터 시스템 및 장치의 집합
- LAN(근거리 통신망) : LAN 비교적 가까운 지리적 영역에 있는 소수의 시스템을 연결하는 네트워크 예로 건물바닥 등
- MAN(수도권망) : 대도시와 그 주변에 개발된 통신 인프라
- WAN(광역 네트워크) : 지리적으로 먼 거리에 걸쳐 둘 이상의 근거리 통신망을 연결하는 네트워크로 주, 지방, 국가 등 넓은 지리적 영역에 걸쳐 있

## http란
- HyperText Transfer Protocol
- 네트워크 장치 간에 정보를 전송하도록 설계된 애플리케이션 계층 프로토콜
- 클라이언트 시스템에서 서버에 요청한 다음 서버에서 응답 메시지를 보내는 작업을 함
- 사용자가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른 것을 통해서 요청(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태로 동작
- Plain text, JSON 데이터, XML, html 등의 형태의 정보 주고 받음

- Request (요청) : 클라이언트가 서버에게 연락하는 것을 요청이라고 하며 요청을 보낼때는 요청에 대한 정보를 담아 서버 보냄

- Request Method (요청의 종류)
    - GET : 자료를 요청할 때 사용
    - POST : 자료의 생성을 요청할 때 사용
    - PUT : 자료의 수정을 요청할 때 사용
    - DELETE : 자료의 삭제를 요청할 때 사용

1. 시작줄 (첫 줄) : 첫 줄은 시작줄로 메서드 구조 버전으로 구성
2. 헤더 (두 번째 줄부터) : 두번째 줄부터는 헤더이며 요청에 대한 정보를 담고 있음
3. 본문 (헤더에서 한 줄 띄고) : 본문은 요청을 할 때 함께 보낼 데이터를 담는 부분

- Response (응답) : 서버가 요청에 대한 답변을 클라이언트에게 보내는 것이 응답
    - 1XX (조건부 응답) : 요청을 받았으며 작업을 계속함
    - 2XX (성공) : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킴
    - 3XX (리다이렉션 완료) : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야함
    - 4XX (요청 오류) : 클라이언트에 오류가 있음을 나타냄
    - 5XX (서버 오류) : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타냄

1. 시작줄 (첫 줄) : 첫 줄은 버전 상태코드 상태메시지로 구성되어 있음. 200은 성공적인 요청이었다는 뜻
2. 헤더 (두 번째 줄부터) : 두 번째 줄부터는 헤더로 응답에 대한 정보를 담고 있음
3. 본문 (헤더 뒤부터) : 응답에는 대부분의 경우 본문이 있음. 보통 데이터를 요청하고 응답 메시지에는 요청한 데이터를 담아서 보내주기 때문이다. 응답 메시지에 HTML이 담겨 있는데 이 HTML을 받아 브라우저가 화면에 렌더링한다.


## http 메서드

- GET : 리소스 조회하는 메서드
    - 예 : 100번 멤버를 조회하고 싶을때 => /members/100
    - 상세한 특정 데이터를 보고 싶을 때는 쿼리스트링를 통해서 전달
    - 예 : GET /members/100?username=inpa&height=200

- POST:  요청 데이터 처리, 주로 등록에 사용
    - 메시지 바디(body)를 통해 서버로 요청 데이터 전달하면 서버는 요청 데이터를 처리하여 업데이트
    - body에 등록할 회원 정보를 JSON 형태로 만들어 담고 서버로 전송

- PUT : 리소스를 대체(덮어쓰기), 해당 리소스가 없으면 생성
    - /members/100 데이터가 존재하면 기존에 것을 완전 대체
    - /members/100 데이터가 없으면 대체 할게 없으니까 새로 생성

- DELETE : 리소스 삭제
    - DELETE /members/100 : 100번째 멤버 삭제

- PATCH : 리소스 부분 변경 (PUT이 전체 변경, PATCH는 일부 변경)
    - 만일 PATCH를 지원하지 않는 서버에서는 대신에 POST를 사용할 수 있음
    - id와 age 중 age만 교체 요청 보냈을 때, id는 그대로있고 age만 교체됨

## http 상태 코드
- 1XX: Informational(정보 제공)
    - 100 : Continue / 계속 진행하라
    - 101 : Switching Protocols / 프로토콜을 전환하라
    - 102 : Processing / (WebDAV) 처리 중
    - 103 ~ 199	Unassigned / 현재 할당되지 않은 상태 코드
- 2XX: Success(성공)
    - 200 : OK / 서버가 요청을 성공적으로 처리
    - 201 : Created / 요청이 처리되어서 새로운 리소스가 생성
    - 202 : Accepted / 요청은 접수하였지만, 처리가 완료되지 않았음
    - 203 : Non-Authoritative Information / 응답 헤더가 오리지널 서버로부터 제공된 것이 아님
    - 204 : No Content / 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없음
    - 205 : Reset Content / 처리를 성공하였고 브라우저의 화면을 리셋해라
    - 206 : Partial Content / 콘텐츠의 일부만을 보낸다
    - 207 : Multi-Status / (WebDAV) 처리 결과의 스테이터스가 여러 개
    - 208 ~ 299	: Unassigned / 현재 할당되지 않은 상태 코드
- 3XX: Redirection(리다이렉션)
    - 300 : Multiple Choices / 선택 항목이 여러 개 있음
    - 301 : Moved Permanently / 지정한 리소스가 새로운 URI로 이동했음
    - 302 : Found / 요청한 리소스를 다른 URI에서 찾았음
    - 303 : See Other / 다른 위치로 요청하셈
    - 304 : Not Modified / 지막 요청 이후 요청한 페이지는 수정되지 않았음
    - 305 : Use Proxy / 지정한 리소스에 액세스하려면 프록시를 통해야 함
    - 306 : (Unused) / 예전 버전에서 사용하다가 현재는 사용하지 않는 상태 코드
    - 307 : Temporary Redirect / 임시로 리다이렉션 요청이 필요함
    - 308~399 : Unassigned / 현재 할당되지 않은 상태 코드
- 4XX: Client Error(클라이언트 에러)
    - 400 : Bad Request / 요청의 구문이 잘못됨
    - 401 : Unauthorized / 지정한 리소스에 대한 액세스 권한이 없음
    - 402 : Payment Required / 정한 리소스를 액세스하기 위해서는 결제가 필요
    - 403 : Forbidden / 지정한 리소스에 대한 액세스가 금지됨
    - 404 : Not Found / 지정한 리소스를 찾을 수 없음
    - 405 : Method Not Allowed / 요청한 URI가 지정한 메소드를 지원하지 않음
    - 406 : Not Acceptable / 라이언트가 Accept-* 헤더에 지정한 항목에 관해 처리할 수 없음
    - 407 : Proxy Authentication Required / 클라이언트는 프록시 서버에 인증이 필요
    - 408 : Request Timeout / 요청을 기다리다 서버에서 타임아웃함
    - 409 : Conflict / 서버가 요청을 수행하는 중에 충돌이 발생
    - 410 : Gone / 지정한 리소스가 이전에는 존재하였지만, 현재는 존재하지 않음
    - 411 : Length Required / 요청 헤더에 Content-Length를 지정해야 함
    - 412 : Precondition Failed / If-Match와 같은 조건부 요청에서 지정한 사전 조건이 서버와 맞지 않음
    - 413 : Request Entity Too Large / 요청 메시지가 너무 큼
    - 414 : Request-URI Too Large / 요청 URI가 너무 길다
    - 415 : Unsupported Media Type / 클라이언트가 지정한 미디어 타입을 서버가 지원하지 않음
    - 416 : Range Not Satisfiable / 클라이언트가 지정한 리소스의 범위가 서버의 리소스 사이즈와 맞지 않음
    - 417 : Expectation Failed / 클라이언트가 지정한 Expect 헤더를 서버가 이해할 수 없음
    - 418 ~ 421	: Unassigned / 현재 할당되지 않은 상태 코드
    - 422 : Unprocessable Entity / (WebDAV) 클라이언트가 송신한 XML이 구문은 맞지만, 의미상 오류가 있음
    - 423 : Locked / (WebDAV) 지정한 리소스는 잠겨있음
    - 424 : Failed Dependency / (WebDAV) 다른 작업의 실패로 인해 본 요청도 실패했음
    - 426 : Upgraded Required / 클라이언트의 프로토콜의 업그레이드가 필요
    - 428 : Precondition Required / If-Match와 같은 사전조건을 지정하는 헤더가 필요
    - 429 : Too Many Requests / 클라이언트가 주어진 시간 동안 너무 많은 요청을 보냄
    - 431 : Request Header Fields Too Large / 헤더의 길이가 너무 큼
    - 444 : Connection Closed Without Response / (NGINX) 응답을 보내지 않고 연결을 종료
    - 451 : Unavailable For Legal Reasons / 법적으로 문제가 있는 리소스를 요청
    - 452 ~ 499	: Unassigned / 현재 할당되지 않은 상태 코드
- 5XX: Server Error(서버 에러)
    - 500 : Internal Server Error / 서버에 에러가 발생
    - 501 : Not Implemented / 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않음
    - 502 : Bad Gateway / 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받음
    - 503 : Service Unavailable / 현재 서버에서 서비스를 제공할 수 없음
    - 504 : Gateway Timeout / 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 응답을 기다리다 타임아웃이 발생
    - 505 : HTTP Version Not Supported / 클라이언트가 요청에 사용한 HTTP 버전을 서버가 지원하지 않음
    - 506 : Unassigned / 현재 할당되지 않은 상태 코드
    - 507 : Insufficient Storage / (WebDAV) 서버에 저장 공간 부족으로 처리에 실패
    - 512 ~ 599	: Unassigned / 현재 할당되지 않은 상태 코드

## Rest API란
- REST를 기반으로 만들어진 API를 의미
- HTTP 프로토콜을 통해 API를 설계하기 위한 아키텍처 스타일
- HTTP 요청을 통해 통신하여 데이터 생성, 읽기, 업데이트 및 삭제 기능을 수행

### 6가지 아키텍처 제약 조건
- 클라이언트 서버 : 클라이언트-서버 아키텍처 스타일을 구현
- 균일한 인터페이스 : 통합 인터페이스는 REST API를 구별하는 필수 요소
    - 균일한 인터페이스 4가지 원칙
        - 자원 식별
        - 표현을 통한 자원 조작
        - 자기 설명 메시지
        - 애플리케이션 상태의 엔진으로서의 하이퍼미디어
- 무국적자 : 서버에 클라이언트에 대한 데이터가 포함되어 있지 않음을 의미
- 캐시 가능 : 각 응답에는 캐시 가능 여부와 응답을 캐시할 수 있는 기간을 알려주는 정보가 있어야함
- 계층화 시스템 : 구성 요소의 동작에 대한 특정 제한을 생성하는 계층 계층을 구현
- 주문형 코드 : 클라이언트가 코드를 다운로드하고 실행할 수 있도록 하는 선택적 기능



### REST란
- Representational State Transfer의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미
1. HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시
2. HTTP Method(POST, GET, PUT, DELETE, PATCH 등)를 통해
3. 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미


## [추가]

## Entity간의 연관 관계의 주인
- https://velog.io/@zenon8485/2.-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91

### 단방향 연관관계
    - 객체의 참조를 통한 연관관계는 언제나 단방향. 객체 간에 연관관계를 양방향으로 가지고 싶으면 서로 참조를 가져야 함. 그러나 이는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개
- @ManyToOne : 이름 그대로 다대일 관계라는 매핑정보
- @JoinColumn : 조인 컬럼은 외래키를 매핑할 때 사용. name 속성에는 매핑할 외래키 이름을 지정. 예 : @JoinColumn(name="TEAM_ID")

### 양방향 연관관계

- 일대다 관계를 매핑하기 위해 @OneToMay 매핑 정보를 사용
- 주인은 mappedBy 속성을 사용하지 않음
- 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 함
- 연관관계의 주인은 테이블에 외래키가 있는 곳으로 정해야 함
- 양방향 연관관계는 연관관계의 주인이 외래키를 관리